"""BPM Diagram Generator using Natural Language.

This module provides utilities to generate BPMN diagrams from BPM process
definitions using ProcessPiper's natural language syntax.
"""

from __future__ import annotations

from typing import Any

from .state_machine import StateMachine, StateDefinition, TransitionDefinition


class DiagramGenerator:
    """Generates BPMN diagrams from BPM process definitions.

    This class converts state machine definitions into ProcessPiper syntax,
    allowing automatic diagram generation from process definitions.

    Example:
        >>> from bpm import StateMachine, StateDefinition, TransitionDefinition
        >>> from bpm.diagram_generator import DiagramGenerator
        >>>
        >>> machine = StateMachine()
        >>> machine.add_state(StateDefinition(name="draft", description="Draft"))
        >>> machine.add_state(StateDefinition(name="approved", description="Approved"))
        >>> machine.add_transition(TransitionDefinition(
        ...     from_state="draft", to_state="approved", name="approve"
        ... ))
        >>>
        >>> generator = DiagramGenerator()
        >>> piperflow_syntax = generator.generate_piperflow(machine, "My Process")
        >>> print(piperflow_syntax)
    """

    def __init__(self, colour_theme: str = "GREENTURTLE"):
        """Initialize diagram generator.

        Args:
            colour_theme: ProcessPiper colour theme to use.
                Options: GREENTURTLE, BLUEMOUNTAIN, GREYWOOF, ORANGEPEEL,
                        SUNFLOWER, PURPLERAIN, RUBYRED, TEALWATERS, SEAFOAMS
        """
        self.colour_theme = colour_theme

    def generate_piperflow(
        self,
        state_machine: StateMachine,
        process_title: str,
        footer: str = "Generated by ProcessPiper from BPM Definition",
        lane_name: str = "Process Flow",
    ) -> str:
        """Generate ProcessPiper PiperFlow syntax from state machine.

        Args:
            state_machine: State machine to convert to diagram.
            process_title: Title for the diagram.
            footer: Footer text for the diagram.
            lane_name: Name of the lane to contain the process.

        Returns:
            ProcessPiper PiperFlow syntax string.
        """
        lines = []

        # Header
        lines.append(f"title: {process_title}")
        lines.append(f"colourtheme: {self.colour_theme}")
        lines.append("")

        # Lane
        lines.append(f"lane: {lane_name}")

        # Add states as elements
        element_refs = {}
        for state_name, state_def in state_machine.states.items():
            element_ref = self._sanitize_ref(state_name)
            element_refs[state_name] = element_ref

            # Determine element type
            if state_name.lower() in ["start", "draft", "initial", "created"]:
                # Start event
                lines.append(f"    (start) as {element_ref}")
            elif state_def.is_terminal or state_name.lower() in ["end", "complete", "closed", "done"]:
                # End event
                lines.append(f"    (end) as {element_ref}")
            elif "approval" in state_name.lower() or "pending" in state_name.lower():
                # Task (waiting state)
                lines.append(f"    [{state_def.description}] as {element_ref}")
            elif "?" in state_def.description or "check" in state_name.lower():
                # Gateway (decision point)
                lines.append(f"    <{state_def.description}> as {element_ref}")
            else:
                # Default task
                lines.append(f"    [{state_def.description}] as {element_ref}")

        lines.append("")

        # Add transitions as connections
        connection_lines = []
        for transition in state_machine.transitions:
            from_ref = element_refs[transition.from_state]
            to_ref = element_refs[transition.to_state]

            # Add label if transition has a meaningful name
            if transition.name and transition.name not in ["", "transition"]:
                connection_lines.append(f"    {from_ref}->{to_ref}: {transition.name}")
            else:
                connection_lines.append(f"    {from_ref}->{to_ref}")

        lines.extend(connection_lines)
        lines.append("")

        # Footer
        lines.append(f"footer: {footer}")

        return "\n".join(lines)

    def generate_piperflow_with_pools(
        self,
        state_machine: StateMachine,
        process_title: str,
        pools_and_lanes: dict[str, list[dict[str, Any]]],
        footer: str = "Generated by ProcessPiper from BPM Definition",
    ) -> str:
        """Generate ProcessPiper syntax with multiple pools and lanes.

        Args:
            state_machine: State machine to convert.
            process_title: Title for the diagram.
            pools_and_lanes: Dictionary mapping pool names to lists of lane configs.
                Format: {
                    "Pool Name": [
                        {"name": "Lane Name", "states": ["state1", "state2"]},
                        ...
                    ]
                }
            footer: Footer text.

        Returns:
            ProcessPiper PiperFlow syntax string.
        """
        lines = []

        # Header
        lines.append(f"title: {process_title}")
        lines.append(f"colourtheme: {self.colour_theme}")
        lines.append("")

        # Build element references
        element_refs = {}
        for state_name in state_machine.states:
            element_refs[state_name] = self._sanitize_ref(state_name)

        # Add pools and lanes
        for pool_name, lanes in pools_and_lanes.items():
            lines.append(f"pool: {pool_name}")

            for lane_config in lanes:
                lane_name = lane_config["name"]
                lane_states = lane_config.get("states", [])

                lines.append(f"    lane: {lane_name}")

                # Add states for this lane
                for state_name in lane_states:
                    if state_name not in state_machine.states:
                        continue

                    state_def = state_machine.states[state_name]
                    element_ref = element_refs[state_name]

                    # Determine element type
                    element_str = self._get_element_string(state_name, state_def)
                    lines.append(f"        {element_str} as {element_ref}")

                lines.append("")

        # Add connections
        connection_lines = []
        for transition in state_machine.transitions:
            from_ref = element_refs[transition.from_state]
            to_ref = element_refs[transition.to_state]

            if transition.name and transition.name not in ["", "transition"]:
                connection_lines.append(f"    {from_ref}->{to_ref}: {transition.name}")
            else:
                connection_lines.append(f"    {from_ref}->{to_ref}")

        lines.extend(connection_lines)
        lines.append("")

        # Footer
        lines.append(f"footer: {footer}")

        return "\n".join(lines)

    def _get_element_string(self, state_name: str, state_def: StateDefinition) -> str:
        """Get ProcessPiper element string for a state.

        Args:
            state_name: Name of the state.
            state_def: State definition.

        Returns:
            ProcessPiper element syntax.
        """
        # Check for start states
        if state_name.lower() in ["start", "draft", "initial", "created"]:
            return "(start)"

        # Check for end states
        if state_def.is_terminal or state_name.lower() in ["end", "complete", "closed", "done", "approved", "rejected"]:
            return "(end)"

        # Check for gateways (decision points)
        if "?" in state_def.description or "check" in state_name.lower() or "decision" in state_name.lower():
            return f"<{state_def.description}>"

        # Check for timer events
        if "timer" in state_name.lower() or "scheduled" in state_name.lower():
            return f"(@timer {state_def.description})"

        # Check for message events
        if "message" in state_name.lower() or "notification" in state_name.lower():
            return f"(@message {state_def.description})"

        # Check for subprocesses
        if "subprocess" in state_name.lower() or "sub_process" in state_name.lower():
            return f"[@subprocess {state_def.description}]"

        # Default to task
        return f"[{state_def.description}]"

    def _sanitize_ref(self, name: str) -> str:
        """Convert state name to valid ProcessPiper reference.

        Args:
            name: State name.

        Returns:
            Sanitized reference name.
        """
        # Replace spaces and special chars with underscores
        ref = name.lower()
        ref = ref.replace(" ", "_")
        ref = ref.replace("-", "_")
        ref = "".join(c if c.isalnum() or c == "_" else "_" for c in ref)
        return ref

    def generate_natural_language_description(
        self,
        state_machine: StateMachine,
    ) -> str:
        """Generate natural language description of the process.

        Args:
            state_machine: State machine to describe.

        Returns:
            Natural language description of the process flow.
        """
        lines = []

        # Overview
        num_states = len(state_machine.states)
        num_transitions = len(state_machine.transitions)

        lines.append(f"This process has {num_states} states and {num_transitions} transitions.")
        lines.append("")

        # Describe states
        lines.append("Process States:")
        for state_name, state_def in state_machine.states.items():
            state_type = "terminal state" if state_def.is_terminal else "intermediate state"
            lines.append(f"  - {state_name}: {state_def.description} ({state_type})")

        lines.append("")

        # Describe transitions
        lines.append("Process Flow:")

        # Group transitions by from_state
        transitions_by_state: dict[str, list[TransitionDefinition]] = {}
        for transition in state_machine.transitions:
            if transition.from_state not in transitions_by_state:
                transitions_by_state[transition.from_state] = []
            transitions_by_state[transition.from_state].append(transition)

        for from_state, transitions in transitions_by_state.items():
            if len(transitions) == 1:
                t = transitions[0]
                action = t.name if t.name else "transitions"
                lines.append(f"  - From '{from_state}', {action} to '{t.to_state}'")
            else:
                lines.append(f"  - From '{from_state}', can transition to:")
                for t in transitions:
                    action = t.name if t.name else "transition"
                    lines.append(f"      â†’ '{t.to_state}' ({action})")

        return "\n".join(lines)


def render_diagram(
    piperflow_syntax: str,
    output_file: str = "process_diagram.png",
    export_bpmn: bool = False,
) -> tuple[str, Any]:
    """Render BPMN diagram from PiperFlow syntax.

    Args:
        piperflow_syntax: PiperFlow syntax string.
        output_file: Output file path (.png or .svg).
        export_bpmn: Whether to export .bpmn XML file.

    Returns:
        Tuple of (generated_code, image).
        Returns (syntax, None) if processpiper is not installed.
    """
    try:
        from processpiper.text2diagram import render

        gen_code, img = render(
            piperflow_syntax,
            output_file=output_file,
            export_to_bpmn=export_bpmn,
        )
        return gen_code, img

    except ImportError:
        print("ProcessPiper not installed. Install with: pip install processpiper")
        print("\nPiperFlow syntax generated:")
        print("=" * 60)
        print(piperflow_syntax)
        print("=" * 60)
        return piperflow_syntax, None
